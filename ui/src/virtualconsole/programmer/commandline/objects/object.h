#ifndef OBJECT_H
#define OBJECT_H

#include <string>

#include <tinyxml.h>

class Object
{
public:
	enum class Type
	{
		Unknown,
		Workspace,
		Fixture,
		Universe
	};
	Object(Type type);
	virtual ~Object();

	///@brief object ID shown to the user. It can be changed by the user, the user can use it for adressing objects using the command line etc. 
	///Because it can change, don't use it for internal addressing (for example referencing fixtures in chases).
	int getExternalId() const { return m_externalId; };
	void setExternalId(int newId) { m_externalId=newId; m_bExternalIdSet=true; };

	///@brief internal ID generated by the program automatically. Use this only internal, don't show it to the user. Use it for referencing other objects.
	int getInternalId() const { return m_internalId; };
	///@brief don't this function manually, it will be used by the object management classes. The internal ID will never change during program runtime. 
	void setInternalId(int id) { m_internalId=id; };

	std::string getTitle() const { return m_title; };
	void setTitle(const std::string& newTitle) { m_title=newTitle; m_bTitleSet=true;};
protected:
	///@brief saves the data from teh newDataObject to this object
	///@return true, if data has been changed
	bool updateObject(const Object& newDataObject);
private:
	//Hack for modify command...
	//TODO better solution...
	bool m_bExternalIdSet=false;
	bool m_bTitleSet=false;
	int m_externalId=-1;
	int m_internalId=-1;
	std::string m_title;
};

#endif
